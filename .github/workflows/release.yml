name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build-and-release:
    name: æž„å»ºå¹¶å‘å¸ƒ - ${{ matrix.name }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: macOS (Apple Silicon)
            platform: macos-latest
            tauriArgs: '--target aarch64-apple-darwin'
          - name: macOS (Universal)
            platform: macos-latest
            tauriArgs: '--target universal-apple-darwin'
          - name: Windows (x64)
            platform: windows-latest
            tauriArgs: '--bundles nsis'
    runs-on: ${{ matrix.platform }}

    steps:
      - name: æ‹‰å–æºä»£ç 
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: å®‰è£… Node.js çŽ¯å¢ƒ
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: å®‰è£… Rust çŽ¯å¢ƒ
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.platform == 'macos-latest' && 'aarch64-apple-darwin,x86_64-apple-darwin' || '' }}

      - name: Rust ç¼“å­˜
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: å®‰è£…ä¾èµ–
        run: npm ci

      - name: èŽ·å–æž„å»ºæ—¶é—´
        shell: bash
        run: |
          BUILD_TIME=$(TZ=Asia/Shanghai date "+%Y-%m-%d %H:%M:%S")
          echo "BUILD_TIME=$BUILD_TIME" >> $GITHUB_ENV
        if: runner.os != 'Windows'

      - name: èŽ·å–æž„å»ºæ—¶é—´ (Windows)
        shell: pwsh
        run: |
          $buildTime = (Get-Date).ToUniversalTime().AddHours(8).ToString("yyyy-MM-dd HH:mm:ss")
          echo "BUILD_TIME=$buildTime" >> $env:GITHUB_ENV
        if: runner.os == 'Windows'

      - name: ç”Ÿæˆ Release Notes
        id: release_notes
        shell: bash
        run: |
          PREV_TAG=$(git describe --tags --abbrev=0 ${{ github.ref_name }}^ 2>/dev/null || git rev-list --max-parents=0 HEAD)
          echo "Previous tag: $PREV_TAG"
          
          LOGS=$(git log $PREV_TAG..${{ github.ref_name }} --pretty=format:"%s")
          
          FEATS=""
          FIXES=""
          DOCS=""
          OTHERS=""
          
          while IFS= read -r line; do
            [ -z "$line" ] && continue
            clean_line=$(echo "$line" | sed 's/\\/\\\\/g; s/`/\\`/g')
            
            if [[ $line =~ ^feat ]]; then
              FEATS="$FEATS\n- ${clean_line#feat: }"
            elif [[ $line =~ ^fix ]]; then
              FIXES="$FIXES\n- ${clean_line#fix: }"
            elif [[ $line =~ ^docs ]]; then
              DOCS="$DOCS\n- ${clean_line#docs: }"
            elif [[ $line =~ ^refactor ]] || [[ $line =~ ^perf ]]; then
              FIXES="$FIXES\n- ${clean_line}"
            else
              OTHERS="$OTHERS\n- ${clean_line}"
            fi
          done <<< "$LOGS"
          
          BODY=""
          [ -n "$FEATS" ] && BODY="$BODY\n### ðŸš€ æ–°åŠŸèƒ½$FEATS\n"
          [ -n "$FIXES" ] && BODY="$BODY\n### ðŸ”§ ä¿®å¤ä¸Žä¼˜åŒ–$FIXES\n"
          [ -n "$DOCS" ] && BODY="$BODY\n### ðŸ“ æ–‡æ¡£æ›´æ–°$DOCS\n"
          [ -n "$OTHERS" ] && BODY="$BODY\n### ðŸ“¦ å…¶ä»–æ”¹åŠ¨$OTHERS\n"
          [ -z "$BODY" ] && BODY="æœ¬æ¬¡å‘å¸ƒåŒ…å«å†…éƒ¨ä¼˜åŒ–ä¸Žç¨³å®šæ€§æå‡ã€‚"
          
          {
            echo "body<<EOF"
            echo -e "$BODY"
            echo ""
            echo "---"
            echo "*æž„å»ºæ—¶é—´: ${{ env.BUILD_TIME }}*"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: æž„å»ºå¹¶å‘å¸ƒ
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          args: ${{ matrix.tauriArgs }} --no-sign
          tagName: ${{ github.ref_name }}
          releaseName: 'OMO Switch ${{ github.ref_name }}'
          releaseBody: |
            ## OMO Switch - AI æ¨¡åž‹åˆ‡æ¢ç®¡ç†å·¥å…·

            ### ðŸš€ æœ¬æ¬¡æ›´æ–°
            ${{ steps.release_notes.outputs.body }}

            ---
            *ç”± GitHub Actions è‡ªåŠ¨æž„å»ºå‘å¸ƒ - ${{ env.BUILD_TIME }}*
          releaseDraft: false
          prerelease: false
          includeUpdaterJson: true
          includeRelease: true

      - name: ç”Ÿæˆ Updater ç­¾å (macOS)
        if: matrix.platform == 'macos-latest'
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          set -euo pipefail

          if [ -z "${TAURI_SIGNING_PRIVATE_KEY:-}" ]; then
            echo "TAURI_SIGNING_PRIVATE_KEY is empty, cannot sign updater bundles." >&2
            exit 1
          fi

          TAG="${{ github.ref_name }}"
          REPO="${{ github.repository }}"
          TARGET_TRIPLE="$(echo "${{ matrix.tauriArgs }}" | sed -E 's/.*--target[[:space:]]+([^[:space:]]+).*/\1/')"
          BUNDLE_DIR="src-tauri/target/$TARGET_TRIPLE/release/bundle/macos"
          UPDATE_BUNDLE="$(ls -1 "$BUNDLE_DIR"/*.app.tar.gz 2>/dev/null | head -n 1 || true)"
          if [ -z "$UPDATE_BUNDLE" ]; then
            echo "Updater bundle not found in: $BUNDLE_DIR" >&2
            ls -la "$BUNDLE_DIR" || true
            exit 1
          fi

          npm run -s tauri -- signer sign -p "${TAURI_SIGNING_PRIVATE_KEY_PASSWORD:-}" "$UPDATE_BUNDLE"
          SIG_PATH="${UPDATE_BUNDLE}.sig"
          if [ ! -f "$SIG_PATH" ]; then
            echo "Signature not generated: $SIG_PATH" >&2
            exit 1
          fi

          if [ "$TARGET_TRIPLE" = "universal-apple-darwin" ]; then
            MATCH_RE="universal.*\\.app\\.tar\\.gz$"
          else
            MATCH_RE="aarch64.*\\.app\\.tar\\.gz$"
          fi
          REMOTE_BUNDLE_NAME="$(gh release view "$TAG" --repo "$REPO" --json assets --jq '.assets[].name' | grep -iE "$MATCH_RE" | head -n 1 || true)"
          if [ -z "$REMOTE_BUNDLE_NAME" ]; then
            REMOTE_BUNDLE_NAME="$(gh release view "$TAG" --repo "$REPO" --json assets --jq '.assets[].name' | grep -iE '\\.app\\.tar\\.gz$' | head -n 1 || true)"
          fi
          if [ -z "$REMOTE_BUNDLE_NAME" ]; then
            echo "Cannot find uploaded updater bundle in GitHub Release assets for $TAG" >&2
            gh release view "$TAG" --repo "$REPO" --json assets --jq '.assets[].name' || true
            exit 1
          fi

          REMOTE_SIG_NAME="${REMOTE_BUNDLE_NAME}.sig"
          cp "$SIG_PATH" "$REMOTE_SIG_NAME"
          gh release upload "$TAG" "$REMOTE_SIG_NAME" --clobber --repo "$REPO"

      - name: ç”Ÿæˆ Updater ç­¾å (Windows)
        if: matrix.platform == 'windows-latest'
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          $ErrorActionPreference = "Stop"

          if (-not $env:TAURI_SIGNING_PRIVATE_KEY) {
            throw "TAURI_SIGNING_PRIVATE_KEY is empty, cannot sign updater bundle."
          }

          $targetDirs = @(
            "src-tauri\target\x86_64-pc-windows-msvc\release\bundle\nsis",
            "src-tauri\target\release\bundle\nsis"
          )

          $setupExe = $null
          foreach ($dir in $targetDirs) {
            if (Test-Path $dir) {
              $setupExe = Get-ChildItem -Path $dir -Filter "*_x64-setup.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($setupExe) { break }
            }
          }

          if (-not $setupExe) {
            throw "No setup exe found for updater signing."
          }

          npm run -s tauri -- signer sign -p $env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD $setupExe.FullName

          $sigPath = "$($setupExe.FullName).sig"
          if (-not (Test-Path $sigPath)) {
            throw "Signature not generated: $sigPath"
          }

          $tag = "${{ github.ref_name }}"
          $repo = "${{ github.repository }}"
          $remoteExeName = gh release view $tag --repo $repo --json assets --jq '.assets[].name' | Where-Object { $_ -match '_x64-setup\.exe$' } | Select-Object -First 1
          if (-not $remoteExeName) {
            throw "Cannot find uploaded setup exe in release assets."
          }

          $remoteSigName = "$remoteExeName.sig"
          Copy-Item -Path $sigPath -Destination $remoteSigName -Force
          gh release upload $tag $remoteSigName --clobber --repo $repo

  publish-updater-json:
    name: å‘å¸ƒ Updater latest.json
    needs: build-and-release
    if: always() && needs.build-and-release.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: ç”Ÿæˆ latest.json å¹¶ä¸Šä¼ 
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          TAG="${{ github.ref_name }}"
          REPO="${{ github.repository }}"
          
          echo "Fetching release info: $REPO $TAG"
          gh api -H 'Accept: application/vnd.github+json' "repos/${REPO}/releases/tags/${TAG}" > release.json
          
          python3 - <<'PY'
          import json, re, urllib.request
          
          with open("release.json", "r", encoding="utf-8") as f:
            data = json.load(f)
          
          tag = data.get("tag_name") or ""
          version = tag[1:] if tag.startswith("v") else tag
          
          assets = data.get("assets") or []
          assets_by_name = {a.get("name"): a for a in assets if a.get("name")}
          
          def find_asset(patterns):
            for pat in patterns:
              rx = re.compile(pat)
              for name, a in assets_by_name.items():
                if rx.search(name):
                  return a
            return None
          
          # macOS bundles (tauri-action ç”Ÿæˆçš„å‘½å)
          mac_arm = find_asset([r"(?i)aarch64.*\.app\.tar\.gz$", r"(?i)\.app\.tar\.gz$.*aarch64"])
          mac_universal = find_asset([r"(?i)universal.*\.app\.tar\.gz$", r"(?i)\.app\.tar\.gz$.*universal"])
          win_exe = find_asset([r"(?i)_x64-setup\.exe$"])
          
          def sig_for(asset):
            if not asset:
              return None
            name = asset["name"]
            return assets_by_name.get(name + ".sig")
          
          mac_arm_sig = sig_for(mac_arm)
          mac_universal_sig = sig_for(mac_universal)
          win_sig = sig_for(win_exe)
          
          def fetch_text(url):
            with urllib.request.urlopen(url, timeout=30) as f:
              return f.read().decode("utf-8").strip()
          
          platforms = {}
          
          # Apple Silicon: ä¼˜å…ˆ aarch64ï¼Œfallback åˆ° universal
          if mac_arm and mac_arm_sig:
            platforms["darwin-aarch64"] = {
              "url": mac_arm["browser_download_url"],
              "signature": fetch_text(mac_arm_sig["browser_download_url"])
            }
          elif mac_universal and mac_universal_sig:
            platforms["darwin-aarch64"] = {
              "url": mac_universal["browser_download_url"],
              "signature": fetch_text(mac_universal_sig["browser_download_url"])
            }
          
          # Intel Mac: ä½¿ç”¨ universal
          if mac_universal and mac_universal_sig:
            platforms["darwin-x86_64"] = {
              "url": mac_universal["browser_download_url"],
              "signature": fetch_text(mac_universal_sig["browser_download_url"])
            }
          
          # Windows
          if win_exe and win_sig:
            platforms["windows-x86_64"] = {
              "url": win_exe["browser_download_url"],
              "signature": fetch_text(win_sig["browser_download_url"])
            }

          required = ["darwin-aarch64", "darwin-x86_64", "windows-x86_64"]
          missing = [k for k in required if k not in platforms]
          if missing:
            raise SystemExit(f"missing required platforms in latest.json: {', '.join(missing)}")
          
          pub_date = data.get("published_at") or data.get("created_at") or ""
          notes = data.get("body") or ""
          
          out = {
            "version": version or tag,
            "notes": notes,
            "pub_date": pub_date,
            "platforms": platforms
          }
          
          with open("latest.json", "w", encoding="utf-8") as f:
            json.dump(out, f, ensure_ascii=False, indent=2)
          
          print("Generated latest.json with platforms:", ", ".join(platforms.keys()))
          PY
          
          gh release upload "$TAG" latest.json --clobber --repo "$REPO"
