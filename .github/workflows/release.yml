name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build-and-release:
    name: æž„å»ºå¹¶å‘å¸ƒ - ${{ matrix.name }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: macOS (Apple Silicon)
            platform: macos-latest
            tauriArgs: '--target aarch64-apple-darwin'
          - name: macOS (Universal)
            platform: macos-latest
            tauriArgs: '--target universal-apple-darwin'
          - name: Windows (x64)
            platform: windows-latest
            tauriArgs: '--bundles nsis'
    runs-on: ${{ matrix.platform }}

    steps:
      - name: æ‹‰å–æºä»£ç 
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: å®‰è£… Node.js çŽ¯å¢ƒ
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: å®‰è£… Rust çŽ¯å¢ƒ
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.platform == 'macos-latest' && 'aarch64-apple-darwin,x86_64-apple-darwin' || '' }}

      - name: Rust ç¼“å­˜
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: å®‰è£…ä¾èµ–
        run: npm ci

      - name: èŽ·å–æž„å»ºæ—¶é—´
        shell: bash
        run: |
          BUILD_TIME=$(TZ=Asia/Shanghai date "+%Y-%m-%d %H:%M:%S")
          echo "BUILD_TIME=$BUILD_TIME" >> $GITHUB_ENV
        if: runner.os != 'Windows'

      - name: èŽ·å–æž„å»ºæ—¶é—´ (Windows)
        shell: pwsh
        run: |
          $buildTime = (Get-Date).ToUniversalTime().AddHours(8).ToString("yyyy-MM-dd HH:mm:ss")
          echo "BUILD_TIME=$buildTime" >> $env:GITHUB_ENV
        if: runner.os == 'Windows'

      - name: ç”Ÿæˆ Release Notes
        id: release_notes
        shell: bash
        run: |
          PREV_TAG=$(git describe --tags --abbrev=0 ${{ github.ref_name }}^ 2>/dev/null || git rev-list --max-parents=0 HEAD)
          echo "Previous tag: $PREV_TAG"
          
          LOGS=$(git log $PREV_TAG..${{ github.ref_name }} --pretty=format:"%s")
          
          FEATS=""
          FIXES=""
          DOCS=""
          OTHERS=""
          
          while IFS= read -r line; do
            [ -z "$line" ] && continue
            clean_line=$(echo "$line" | sed 's/\\/\\\\/g; s/`/\\`/g')
            
            if [[ $line =~ ^feat ]]; then
              FEATS="$FEATS\n- ${clean_line#feat: }"
            elif [[ $line =~ ^fix ]]; then
              FIXES="$FIXES\n- ${clean_line#fix: }"
            elif [[ $line =~ ^docs ]]; then
              DOCS="$DOCS\n- ${clean_line#docs: }"
            elif [[ $line =~ ^refactor ]] || [[ $line =~ ^perf ]]; then
              FIXES="$FIXES\n- ${clean_line}"
            else
              OTHERS="$OTHERS\n- ${clean_line}"
            fi
          done <<< "$LOGS"
          
          BODY=""
          [ -n "$FEATS" ] && BODY="$BODY\n### ðŸš€ æ–°åŠŸèƒ½$FEATS\n"
          [ -n "$FIXES" ] && BODY="$BODY\n### ðŸ”§ ä¿®å¤ä¸Žä¼˜åŒ–$FIXES\n"
          [ -n "$DOCS" ] && BODY="$BODY\n### ðŸ“ æ–‡æ¡£æ›´æ–°$DOCS\n"
          [ -n "$OTHERS" ] && BODY="$BODY\n### ðŸ“¦ å…¶ä»–æ”¹åŠ¨$OTHERS\n"
          [ -z "$BODY" ] && BODY="æœ¬æ¬¡å‘å¸ƒåŒ…å«å†…éƒ¨ä¼˜åŒ–ä¸Žç¨³å®šæ€§æå‡ã€‚"
          
          {
            echo "body<<EOF"
            echo -e "$BODY"
            echo ""
            echo "---"
            echo "*æž„å»ºæ—¶é—´: ${{ env.BUILD_TIME }}*"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: æž„å»ºå¹¶å‘å¸ƒ
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          args: ${{ matrix.tauriArgs }} --no-sign
          tagName: ${{ github.ref_name }}
          releaseName: 'OMO Switch ${{ github.ref_name }}'
          releaseBody: |
            ## OMO Switch - AI æ¨¡åž‹åˆ‡æ¢ç®¡ç†å·¥å…·

            ### ðŸš€ æœ¬æ¬¡æ›´æ–°
            ${{ steps.release_notes.outputs.body }}

            ---
            *ç”± GitHub Actions è‡ªåŠ¨æž„å»ºå‘å¸ƒ - ${{ env.BUILD_TIME }}*
          releaseDraft: false
          prerelease: false
          includeUpdaterJson: false
          includeRelease: true

      - name: ç”Ÿæˆ Updater ç­¾å (macOS)
        if: matrix.platform == 'macos-latest'
        continue-on-error: true
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          if [ -z "${TAURI_SIGNING_PRIVATE_KEY:-}" ]; then
            echo "No signing key, skip signature generation"
            exit 0
          fi
          
          # è§£æž target
          if [[ "${{ matrix.tauriArgs }}" == *"universal"* ]]; then
            TARGET="universal-apple-darwin"
          else
            TARGET="aarch64-apple-darwin"
          fi
          
          # å°è¯•å¤šä¸ªå¯èƒ½çš„ç›®å½•
          for BUNDLE_DIR in \
            "src-tauri/target/$TARGET/release/bundle/macos" \
            "src-tauri/target/release/bundle/macos"
          do
            if [ -d "$BUNDLE_DIR" ]; then
              echo "Found bundle dir: $BUNDLE_DIR"
              UPDATE_BUNDLE=$(ls -1 "$BUNDLE_DIR"/*.app.tar.gz 2>/dev/null | head -n 1 || true)
              if [ -n "$UPDATE_BUNDLE" ]; then
                break
              fi
            fi
          done
          
          if [ -z "${UPDATE_BUNDLE:-}" ]; then
            echo "No updater bundle found, skipping"
            exit 0
          fi
          
          # ä½¿ç”¨çŽ¯å¢ƒå˜é‡ç­¾å
          npm run -s tauri -- signer sign -p "${TAURI_SIGNING_PRIVATE_KEY_PASSWORD}" "$UPDATE_BUNDLE"
          echo "Signature generated: ${UPDATE_BUNDLE}.sig"
          
          # ä¸Šä¼ ç­¾åæ–‡ä»¶
          TAG="${{ github.ref_name }}"
          REPO="${{ github.repository }}"
          gh release upload "$TAG" "${UPDATE_BUNDLE}.sig" --clobber --repo "$REPO"

      - name: ç”Ÿæˆ Updater ç­¾å (Windows)
        if: matrix.platform == 'windows-latest'
        continue-on-error: true
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          if (-not $env:TAURI_SIGNING_PRIVATE_KEY) {
            Write-Host "No signing key, skip signature generation"
            exit 0
          }
          
          # å°è¯•å¤šä¸ªå¯èƒ½çš„ç›®å½•
          $targetDirs = @(
            "src-tauri\target\x86_64-pc-windows-msvc\release\bundle\nsis",
            "src-tauri\target\release\bundle\nsis"
          )
          
          $setupExe = $null
          foreach ($dir in $targetDirs) {
            if (Test-Path $dir) {
              Write-Host "Found bundle dir: $dir"
              $setupExe = Get-ChildItem -Path $dir -Filter "*_x64-setup.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($setupExe) { break }
            }
          }
          
          if (-not $setupExe) {
            Write-Host "No setup exe found, skipping"
            exit 0
          }
          
          # ä½¿ç”¨çŽ¯å¢ƒå˜é‡ç­¾å
          npm run tauri -- signer sign -p $env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD $setupExe.FullName
          Write-Host "Signature generated: $($setupExe.FullName).sig"
          
          # ä¸Šä¼ ç­¾åæ–‡ä»¶
          gh release upload "${{ github.ref_name }}" "$($setupExe.FullName).sig" --clobber --repo "${{ github.repository }}"

  publish-updater-json:
    name: å‘å¸ƒ Updater latest.json
    needs: build-and-release
    if: always() && needs.build-and-release.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: ç”Ÿæˆ latest.json å¹¶ä¸Šä¼ 
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ github.ref_name }}"
          REPO="${{ github.repository }}"
          
          echo "Fetching release info: $REPO $TAG"
          gh api -H 'Accept: application/vnd.github+json' "repos/${REPO}/releases/tags/${TAG}" > release.json
          
          python3 - <<'PY'
          import json, re, urllib.request, sys
          
          with open("release.json", "r", encoding="utf-8") as f:
            data = json.load(f)
          
          tag = data.get("tag_name") or ""
          version = tag[1:] if tag.startswith("v") else tag
          
          assets = data.get("assets") or []
          assets_by_name = {a.get("name"): a for a in assets if a.get("name")}
          
          def find_asset(patterns):
            for pat in patterns:
              rx = re.compile(pat)
              for name, a in assets_by_name.items():
                if rx.search(name):
                  return a
            return None
          
          # macOS bundles (tauri-action ç”Ÿæˆçš„å‘½å)
          mac_arm = find_asset([r"aarch64.*\.app\.tar\.gz$", r"OMO.*aarch64.*\.app\.tar\.gz$"])
          mac_universal = find_asset([r"universal.*\.app\.tar\.gz$", r"OMO.*universal.*\.app\.tar\.gz$"])
          win_exe = find_asset([r"_x64-setup\.exe$", r"OMO.*x64.*\.exe$"])
          
          def sig_for(asset):
            if not asset:
              return None
            name = asset["name"]
            return assets_by_name.get(name + ".sig")
          
          mac_arm_sig = sig_for(mac_arm)
          mac_universal_sig = sig_for(mac_universal)
          win_sig = sig_for(win_exe)
          
          def fetch_text(url):
            try:
              with urllib.request.urlopen(url, timeout=30) as f:
                return f.read().decode("utf-8").strip()
            except Exception as e:
              print(f"Warning: Failed to fetch {url}: {e}", file=sys.stderr)
              return ""
          
          platforms = {}
          
          # Apple Silicon: ä¼˜å…ˆ aarch64ï¼Œfallback åˆ° universal
          if mac_arm and mac_arm_sig:
            sig_content = fetch_text(mac_arm_sig["browser_download_url"])
            if sig_content:
              platforms["darwin-aarch64"] = {
                "url": mac_arm["browser_download_url"],
                "signature": sig_content
              }
          elif mac_universal and mac_universal_sig:
            sig_content = fetch_text(mac_universal_sig["browser_download_url"])
            if sig_content:
              platforms["darwin-aarch64"] = {
                "url": mac_universal["browser_download_url"],
                "signature": sig_content
              }
          
          # Intel Mac: ä½¿ç”¨ universal
          if mac_universal and mac_universal_sig:
            sig_content = fetch_text(mac_universal_sig["browser_download_url"])
            if sig_content:
              platforms["darwin-x86_64"] = {
                "url": mac_universal["browser_download_url"],
                "signature": sig_content
              }
          
          # Windows
          if win_exe and win_sig:
            sig_content = fetch_text(win_sig["browser_download_url"])
            if sig_content:
              platforms["windows-x86_64"] = {
                "url": win_exe["browser_download_url"],
                "signature": sig_content
              }
          
          if not platforms:
            print("ERROR: No platforms collected", file=sys.stderr)
            sys.exit(1)
          
          pub_date = data.get("published_at") or data.get("created_at") or ""
          notes = data.get("body") or ""
          
          out = {
            "version": version or tag,
            "notes": notes,
            "pub_date": pub_date,
            "platforms": platforms
          }
          
          with open("latest.json", "w", encoding="utf-8") as f:
            json.dump(out, f, ensure_ascii=False, indent=2)
          
          print("Generated latest.json with platforms:", ", ".join(platforms.keys()))
          PY
          
          gh release upload "$TAG" latest.json --clobber --repo "$REPO"
