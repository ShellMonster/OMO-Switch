name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build-and-release:
    name: æ„å»ºå¹¶å‘å¸ƒ - ${{ matrix.name }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: macOS (Apple Silicon)
            platform: macos-latest
            tauriArgs: '--target aarch64-apple-darwin'
          - name: macOS (Universal)
            platform: macos-latest
            tauriArgs: '--target universal-apple-darwin'
          - name: Windows (x64)
            platform: windows-latest
            tauriArgs: '--bundles nsis'
    runs-on: ${{ matrix.platform }}
    env:
      # Tauri Updater ç­¾åå¯†é’¥ï¼ˆåœ¨ job çº§åˆ«è®¾ç½®ï¼Œç­¾åæ­¥éª¤ä¸å†è¦†ç›–ï¼‰
      TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
      TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}

    steps:
      - name: æ‹‰å–æºä»£ç 
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: å®‰è£… Node.js ç¯å¢ƒ
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: å®‰è£… Rust ç¯å¢ƒ
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.platform == 'macos-latest' && 'aarch64-apple-darwin,x86_64-apple-darwin' || '' }}

      - name: Rust ç¼“å­˜
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: å®‰è£…ä¾èµ–
        run: npm ci

      - name: è·å–æ„å»ºæ—¶é—´
        shell: bash
        run: |
          BUILD_TIME=$(TZ=Asia/Shanghai date "+%Y-%m-%d %H:%M:%S")
          echo "BUILD_TIME=$BUILD_TIME" >> $GITHUB_ENV
        if: runner.os != 'Windows'

      - name: è·å–æ„å»ºæ—¶é—´ (Windows)
        shell: pwsh
        run: |
          $buildTime = (Get-Date).ToUniversalTime().AddHours(8).ToString("yyyy-MM-dd HH:mm:ss")
          echo "BUILD_TIME=$buildTime" >> $env:GITHUB_ENV
        if: runner.os == 'Windows'

      - name: ç”Ÿæˆ Release Notes
        id: release_notes
        shell: bash
        run: |
          PREV_TAG=$(git describe --tags --abbrev=0 ${{ github.ref_name }}^ 2>/dev/null || git rev-list --max-parents=0 HEAD)
          echo "Previous tag: $PREV_TAG"
          
          LOGS=$(git log $PREV_TAG..${{ github.ref_name }} --pretty=format:"%s")
          
          FEATS=""
          FIXES=""
          DOCS=""
          OTHERS=""
          
          while IFS= read -r line; do
            [ -z "$line" ] && continue
            clean_line=$(echo "$line" | sed 's/\\/\\\\/g; s/`/\\`/g')
            
            if [[ $line =~ ^feat ]]; then
              FEATS="$FEATS\n- ${clean_line#feat: }"
            elif [[ $line =~ ^fix ]]; then
              FIXES="$FIXES\n- ${clean_line#fix: }"
            elif [[ $line =~ ^docs ]]; then
              DOCS="$DOCS\n- ${clean_line#docs: }"
            elif [[ $line =~ ^refactor ]] || [[ $line =~ ^perf ]]; then
              FIXES="$FIXES\n- ${clean_line}"
            else
              OTHERS="$OTHERS\n- ${clean_line}"
            fi
          done <<< "$LOGS"
          
          BODY=""
          [ -n "$FEATS" ] && BODY="$BODY\n### ğŸš€ æ–°åŠŸèƒ½$FEATS\n"
          [ -n "$FIXES" ] && BODY="$BODY\n### ğŸ”§ ä¿®å¤ä¸ä¼˜åŒ–$FIXES\n"
          [ -n "$DOCS" ] && BODY="$BODY\n### ğŸ“ æ–‡æ¡£æ›´æ–°$DOCS\n"
          [ -n "$OTHERS" ] && BODY="$BODY\n### ğŸ“¦ å…¶ä»–æ”¹åŠ¨$OTHERS\n"
          [ -z "$BODY" ] && BODY="æœ¬æ¬¡å‘å¸ƒåŒ…å«å†…éƒ¨ä¼˜åŒ–ä¸ç¨³å®šæ€§æå‡ã€‚"
          
          {
            echo "body<<EOF"
            echo -e "$BODY"
            echo ""
            echo "---"
            echo "*æ„å»ºæ—¶é—´: ${{ env.BUILD_TIME }}*"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: æ„å»ºå¹¶å‘å¸ƒ (macOS Unsigned)
        if: matrix.platform == 'macos-latest'
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          args: ${{ matrix.tauriArgs }} --no-sign
          tagName: ${{ github.ref_name }}
          releaseName: 'OMO Switch ${{ github.ref_name }}'
          releaseBody: |
            ## OMO Switch - AI æ¨¡å‹åˆ‡æ¢ç®¡ç†å·¥å…·

            ### ğŸš€ æœ¬æ¬¡æ›´æ–°
            ${{ steps.release_notes.outputs.body }}

            ---
            *ç”± GitHub Actions è‡ªåŠ¨æ„å»ºå‘å¸ƒ - ${{ env.BUILD_TIME }}*
          releaseDraft: false
          prerelease: false
          includeUpdaterJson: true
          includeRelease: true

      - name: æ„å»ºå¹¶å‘å¸ƒ (Windows)
        if: matrix.platform == 'windows-latest'
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          args: ${{ matrix.tauriArgs }}
          tagName: ${{ github.ref_name }}
          releaseName: 'OMO Switch ${{ github.ref_name }}'
          releaseBody: |
            ## OMO Switch - AI æ¨¡å‹åˆ‡æ¢ç®¡ç†å·¥å…·

            ### ğŸš€ æœ¬æ¬¡æ›´æ–°
            ${{ steps.release_notes.outputs.body }}

            ---
            *ç”± GitHub Actions è‡ªåŠ¨æ„å»ºå‘å¸ƒ - ${{ env.BUILD_TIME }}*
          releaseDraft: false
          prerelease: false
          includeUpdaterJson: true
          includeRelease: true

      # macOS ä¸‹å¦‚æœä½¿ç”¨ `--no-sign`ï¼Œä¼šåŒæ—¶è·³è¿‡ Updater(minisign)ç­¾åã€‚
      # ä¸ºç¡®ä¿ App å†…"æ£€æŸ¥æ›´æ–°"å¯ç”¨ï¼Œè¿™é‡Œç»Ÿä¸€å¯¹ .app.tar.gz ç”Ÿæˆå¹¶ä¸Šä¼  .sig
      - name: ç”Ÿæˆå¹¶ä¸Šä¼  Updater ç­¾å (macOS)
        if: matrix.platform == 'macos-latest'
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          
          if [ -z "${TAURI_SIGNING_PRIVATE_KEY:-}" ]; then
            echo "TAURI_SIGNING_PRIVATE_KEY is empty, cannot sign updater bundles." >&2
            exit 1
          fi
          
          REPO="${{ github.repository }}"
          TAG="${{ github.ref_name }}"
          
          KEY_PATH="$RUNNER_TEMP/tauri-updater.key"
          printf '%s' "$TAURI_SIGNING_PRIVATE_KEY" > "$KEY_PATH"
          
          TARGET_DIR="src-tauri/target"
          # matrix.tauriArgs å½¢å¦‚: "--target aarch64-apple-darwin" / "--target universal-apple-darwin"
          TARGET_TRIPLE="$(echo "${{ matrix.tauriArgs }}" | sed -E 's/.*--target[[:space:]]+([^[:space:]]+).*/\1/')"
          BUNDLE_DIR="$TARGET_DIR/$TARGET_TRIPLE/release/bundle/macos"
          
          UPDATE_BUNDLE="$(ls -1 "$BUNDLE_DIR"/*.app.tar.gz | head -n 1 || true)"
          if [ -z "$UPDATE_BUNDLE" ]; then
            echo "Updater bundle not found in: $BUNDLE_DIR" >&2
            ls -la "$BUNDLE_DIR" || true
            exit 1
          fi
          
          echo "Signing bundle: $UPDATE_BUNDLE"
          # ç”Ÿæˆ .sigï¼ˆè¾“å‡ºè·¯å¾„ä¸º <file>.sigï¼‰
          npm run -s tauri -- signer sign -f "$KEY_PATH" -p "${TAURI_SIGNING_PRIVATE_KEY_PASSWORD:-}" "$UPDATE_BUNDLE"
          
          SIG_PATH="${UPDATE_BUNDLE}.sig"
          if [ ! -f "$SIG_PATH" ]; then
            echo "Signature not generated: $SIG_PATH" >&2
            exit 1
          fi
          
          # ä¸Šä¼ åˆ° Releaseï¼ˆè¦†ç›–åŒåæ–‡ä»¶ï¼Œä¾¿äºé‡è·‘ï¼‰
          # æ³¨æ„ï¼štauri-action å¯èƒ½ä¼šåœ¨ä¸Šä¼ æ—¶é‡å‘½å updater bundleï¼ˆä¾‹å¦‚ï¼šOMO_aarch64.app.tar.gzï¼‰ã€‚
          # ä¸ºç¡®ä¿ latest.json èƒ½é€šè¿‡ "<bundle>.sig" æ‰¾åˆ°ç­¾åï¼Œè¿™é‡ŒæŠŠæœ¬åœ°ç”Ÿæˆçš„ .sig é‡å‘½åæˆ Release ä¸Šçš„ bundle æ–‡ä»¶å + .sig å†ä¸Šä¼ ã€‚
          if [ "$TARGET_TRIPLE" = "universal-apple-darwin" ]; then
            MATCH_RE="universal.*\\.app\\.tar\\.gz$"
          else
            MATCH_RE="aarch64.*\\.app\\.tar\\.gz$"
          fi
          
          REMOTE_BUNDLE_NAME="$(gh release view "$TAG" --repo "$REPO" --json assets --jq '.assets[].name' | grep -iE "$MATCH_RE" | head -n 1 || true)"
          if [ -z "$REMOTE_BUNDLE_NAME" ]; then
            # å…œåº•ï¼šå¦‚æœæ²¡æœ‰æŒ‰æ¶æ„å‘½åï¼Œç›´æ¥å–ç¬¬ä¸€ä¸ª *.app.tar.gz
            REMOTE_BUNDLE_NAME="$(gh release view "$TAG" --repo "$REPO" --json assets --jq '.assets[].name' | grep -iE '\\.app\\.tar\\.gz$' | head -n 1 || true)"
          fi
          
          if [ -z "$REMOTE_BUNDLE_NAME" ]; then
            echo "Cannot find uploaded updater bundle in GitHub Release assets for $TAG" >&2
            gh release view "$TAG" --repo "$REPO" --json assets --jq '.assets[].name' || true
            exit 1
          fi
          
          REMOTE_SIG_NAME="${REMOTE_BUNDLE_NAME}.sig"
          cp "$SIG_PATH" "$REMOTE_SIG_NAME"
          gh release upload "$TAG" "$REMOTE_SIG_NAME" --clobber --repo "$REPO"
          echo "Uploaded signature: $REMOTE_SIG_NAME"

  publish-updater-json:
    name: å‘å¸ƒ Updater latest.json
    needs: build-and-release
    if: always()
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: ç”Ÿæˆ latest.json å¹¶ä¸Šä¼ 
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          
          TAG="${{ github.ref_name }}"
          REPO="${{ github.repository }}"
          
          echo "Fetching release info: $REPO $TAG"
          gh api -H 'Accept: application/vnd.github+json' "repos/${REPO}/releases/tags/${TAG}" > release.json
          
          # ä½¿ç”¨ python æ„å»º platforms æ˜ å°„ï¼ˆä» Release èµ„äº§é‡Œæ‰¾ bundle ä¸ .sigï¼‰
          python3 - <<'PY'
          import json, re, urllib.request
          
          with open("release.json", "r", encoding="utf-8") as f:
            data = json.load(f)
          
          tag = data.get("tag_name") or ""
          version = tag[1:] if tag.startswith("v") else tag
          
          assets = data.get("assets") or []
          assets_by_name = {a.get("name"): a for a in assets if a.get("name")}
          
          def find_asset(patterns):
            for pat in patterns:
              rx = re.compile(pat)
              for name, a in assets_by_name.items():
                if rx.search(name):
                  return a
            return None
          
          # macOS: updater bundle æ˜¯ *.app.tar.gz + *.app.tar.gz.sig
          mac_arm = find_asset([r"(?i)aarch64.*\.app\.tar\.gz$", r"(?i)\.app\.tar\.gz$.*aarch64"])
          mac_universal = find_asset([r"(?i)universal.*\.app\.tar\.gz$", r"(?i)\.app\.tar\.gz$.*universal"])
          
          # windows: createUpdaterArtifacts=true æ¨¡å¼ä¸‹ï¼Œupdater å¤ç”¨ setup.exe + setup.exe.sig
          win_exe = find_asset([r"(?i)_x64-setup\.exe$"])
          
          # å¯¹åº” .sigï¼ˆä¼˜å…ˆåŒå + .sigï¼‰
          def sig_for(asset):
            if not asset:
              return None
            name = asset["name"]
            return assets_by_name.get(name + ".sig")
          
          mac_arm_sig = sig_for(mac_arm)
          mac_universal_sig = sig_for(mac_universal)
          win_sig = sig_for(win_exe)
          
          def fetch_text(url):
            with urllib.request.urlopen(url) as f:
              return f.read().decode("utf-8").strip()
          
          platforms = {}
          # Apple Siliconï¼šä¼˜å…ˆ aarch64ï¼›è‹¥ç¼ºå¤±åˆ™å›é€€åˆ° universal
          if mac_arm and mac_arm_sig:
            platforms["darwin-aarch64"] = {"url": mac_arm["browser_download_url"], "signature": fetch_text(mac_arm_sig["browser_download_url"])}
          elif mac_universal and mac_universal_sig:
            platforms["darwin-aarch64"] = {"url": mac_universal["browser_download_url"], "signature": fetch_text(mac_universal_sig["browser_download_url"])}
          
          # Intelï¼šä½¿ç”¨ universal æ›´æ–°åŒ…
          if mac_universal and mac_universal_sig:
            platforms["darwin-x86_64"] = {"url": mac_universal["browser_download_url"], "signature": fetch_text(mac_universal_sig["browser_download_url"])}
          
          if win_exe and win_sig:
            platforms["windows-x86_64"] = {"url": win_exe["browser_download_url"], "signature": fetch_text(win_sig["browser_download_url"])}
          
          if not platforms:
            raise SystemExit("no platforms collected; cannot generate latest.json")
          
          pub_date = data.get("published_at") or data.get("created_at") or ""
          notes = data.get("body") or ""
          out = {"version": version or tag, "notes": notes, "pub_date": pub_date, "platforms": platforms}
          
          with open("latest.json", "w", encoding="utf-8") as f:
            json.dump(out, f, ensure_ascii=False, indent=2)
          print("Generated latest.json with platforms:", ", ".join(platforms.keys()))
          PY
          
          gh release upload "$TAG" latest.json --clobber --repo "$REPO"
